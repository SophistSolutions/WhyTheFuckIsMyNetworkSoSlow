Top priority bug:

* see why on unix - WTF uninstall very slow 
  sudo apt-get remove whythefuckismynetworksoslow

* IMPLEMENT FILTER API, so can easily
  filte by active/selected network 
  so on UNIX boxes we dont see the 172.x devices
  (and maybe see why we dont discover more about them)


* Good low haning fruit 'probe' to see what kind of machine:
   nc 192.168.244.32 22
	SSH-2.0-OpenSSH_7.4p1 Raspbian-10+deb9u6
	^C
	(ie TCP Connect to port 22, and do a quick read, and see what comes back)


Similarly look for netbios:
	netbios-ssn
		Description: 	
		TCP NetBIOS connections are made over this port, usually with Windows machines but also with any other system running Samba (SMB). These TCP connections form "NetBIOS sessions" to support connection oriented file sharing activities.

		Related Ports: 	
		137, 138, 445
			135/tcp  open  msrpc         Microsoft Windows RPC
			139/tcp  open  netbios-ssn   Microsoft Windows netbios-ssn
			445/tcp  open  microsoft-ds?

* Maybe throw in LastHeardFromAt DATETIME for each device?
  (could be misleading cuz not trying to reach each device and may never hear from them)


* New feature - in app - keep track of how long since last question about devices etc.
  If getting pinged alot, automatically adjust 'frequency' setting and have that drive
  how aggressively we do discovery.

  OR - base it on how long since last change (since we found something new). Maybe disable
  SEARCH if we havent found anything new in a while (or do less often). Anyhow - have a 
  variable/mdoule capturing this idea of how hard we discover, and let the drive some of our 
  timing values.

* MAYBE automatically add the 6-4 CIDR for V6 networks, to show the mapped V4 range (so any bindings would show up for those devices)

* Why my 'router' not showing up as 'network infrastructure' as well.
  Maybe I did that on purpose? Should automatically list (in enum) all implied types or 
  provide API to get from a type list of all implied types so GUI can decide what to show? Or maybe
  not needed?

* On linux linux, device shows as Linux, but on windows with much more detail (version)

* fix empty device record - no name, no addresses - nothing? Not sure where that comes from
  (windows only)

* use network interfaces 'friendlyname' to suggest default freindlyname for networks.
  (can be done in GUI - for network - from attachedInterfcae, lookup list of 'friendlynames')


*	UNIX not showing dns Servers
   cat /etc/resolve.conf (look for nameservers)
   if its got a comment about autmatically done by systemd
	systemd-resolve --status
	grep DNS Server: 


---

> Fix parsing of SSDP presentationURL, and see that it shows up properly in the web GUI for devices (all the
  rest should be plumbed - just the stroika ssdp parse code is questionable/incomplete)
	- Improve UPnP::DeSerialize () - so it includes device icons (url to icon)
	 (or icon by blob)



* Fix top level makefile so checks for if npm is installed (check-prerequesites)

* Probably need TWO classes of IDs - CURRENT (dynamically generated with GUID-GEN), and PERSISTENT IDs
  During a session, the dynamic ID wont change, but the persistent ID can change as we gain more information
  and better match.

  Generally the GUI will use the persistent IDs (though they can change during a session)

  This applies to DEVICES and NETWORKS (as these must be smartly matched/guessed). It MAY or may not apply to
  networkinterfaces. Probably a good idea there too if for no other reason than consistency

  And note that for NETWORK IDS, we want to PRIMARILY drive the MATCHING logic based on the HARDWARE ADDRESS of
  the gateway. I THINK that will in general be the best indicator.

* Add a few more helpful network idientifiers under Network object
     SSIDs
	 NetworkNames (from the adapaters on the network, can be more than one, and can be misleading; maybe call it NetworkAdapterNames)

> Redo identification of speaker based on services
  Service-ID: 'urn:upnp-org:serviceId:AudioIn'
		(lookup spec to be sure - seems a good guess)


- On unix - see why 'wifi0' is displayed as "Wired Ethernet" type? SB wireless!


	
- consider if its useful to incporperate https://github.com/the-tcpdump-group/libpcap/blob/master/doc/README.Win32.md to 
  scan net traffic


### Ports found open on what devices (DISCOVERY HINTS)
- at Univ Wisconsin, found 631/tcp closed ipp, which is INternetPrining, so COULD MAYBE be
  a printer???
-  

## THINGS TO ASK BOB TODO:
- ask bob how to turn on/off debug mode - nice if user settable option (dialog) 
  or at worst ?debugmode=true on url; in general - how do we handle configuraiton
- suggest to bob fix scroller so doesn't scroll heading - just the bottom alreayd
- some sort of grouping of devices
- auto-refresh list of devices in the background (really cool if could animate additions/removeals/changes)
- in about box just aggregate release notes in build - and link to from about box
- THEN - with those basics out of the way - time to talk about next-gen GUI
- filter by 'search string'
- filter by 'network'
- filter by 'present now'

- Look into using
  https://github.com/nmap/nmap/blob/master/FPEngine.cc
	(etc)
	for device type discovery


- maybe setup WTF website (or section of sophists site)


- ADD "OS" to properties assocaited with a device 
  Typically "Windows" or "Linux" (?useful?). Make it structure, with extra info
	Windows {build : n, edition : x}
	Linux { "distribution ubuntu 1404"}
	Unix { some otehr posix based unix}
	MacOS { version }
	(partly done but need more details, and collect for remote devices)

	*** DEFINE GENERIC OS-INFO object. Use in each device and in AboutInfo object - for what we are running on.
	    See how 'about' object fits with the /data-providers idea? Maybe there is where to declare at least
			this data provider?


>> ADD TO WS DATA MODEL - 'THIS DEVICE' 
flag so you can tell which device is the one querying
  (flag saying "WTFDataProvider: URL) - our 8000 url)
	(and field saying data-collected-by, but not sure where since belongs as higher level elt)
	(and returning an array here); COULD aggregatate array or could have separate API or use HTTP-header
	(ah -if we say 'data provider url and its teh same were fetching from we know same source. maybe have data provider url and GUID)
	{wtf-data-provider: {guid: xxx; url: xxx}}

maybe GET /data-providers

and data-provider guid (or set) arg allowed in fetch of devices



>>> Why sonos devices in family room (play5s) not showing up their roomname (works about 1/2 the time - works for other speakers)



>>> Add "Device ICON UrL" support and push all the way to GUI, so Bob can fetch that image and display



> Need ChangeCount mechanism - where you wait to get notified on changes 

  - use condition variable
	- when a change happens in network data (or device data) - we up a change ChangeCount and notify
	- define associated callbacks that get called on change
	- have thread driving callbacks
	- thread smart enuf to to re-call callbacks if change happens AGAIN while handling reaction


struct ChangeMonitor {
	ChangeMonitor ();	// starts monitoring
	~ChangeMonitor (); aborts and waits for callbacks if needed

	void AddCallback (Function<> cb);
	void RemoveCallback (Function<> cb);
	void NoteChanged ();

	uint64_t GetChangeCount () const;

private:
	Thread::CleanupPtr fChangeMonitorThread;
	Set<Function<>> fCallbacks;
	ConditionVariable<> fWaitOn;
	atomicuint64_t fChangeCount;
}


- Use Cache object on URL looks (GET) for SSDP data. That's probably one of the more expensive items to
  lookup, and esp if we cache the (negative cache) resulkt of failed fetch (bad url) - we can save item.
	Just write utility function to lookup (URL u) -> SSDP::DEscription  - and have it maintain the cache object.
	For a given url, probably no value in lookup more than once per hour or day? Or better - maybe use GetIFMODIFIED and save
	ETAGS in that cache structure (may need new stroika cache for this).

  - MAYBE add obj wrapper on client connection object which maintains cache? and uses ETAGS?



>>> When we recive SSDP events we get many for a given device (rooot and subdevies).
Add tracking info about time we've seen alive (and maybe if we ping it - time we know dead) ; so times KNOWN alive and times KNOWN
dead? Unsure how to handle hte in-betweens. Need some good guessing strategy or only report known info?


Need notificyuatopm/event when netowrk changes
	WHEN - must re-run over list of devices andu
	update thier list of networks.

	And maybe more

-- and separate issue as performance tweek see if I can register in stroikaroota
on network change event so I can avoid polling but poling OK to start.



GetMyDEvice needs its own thread (waiting on notification thatnetwork changed). Condition variable notify all.



	(then add a thread that periodically calls arp -a)
	(then eventually add another thread that walks all available active networks and randoming pings in that range to discover)







---
[0x00005bb4][0115.326]		<Router::Rep_::HandleMessage ((...method=GET,url=http:favicon.ico))> {
[0x00005bb4][0115.335]			Throwing exception: HTTP exception: status 405 (Method Not allowed) from 
Exception thrown at 0x00007FF959CD5549 in WhyTheFuckIsMyNetworkSoSlow-Backend.exe: Microsoft C++ exception: Stroika::Foundation::IO::Network::HTTP::ClientErrorException at memory location 0x000000000326C9E0.


WSAPI above - if we fetch soemting that we dont have issue 404 and only 405 if it was ebcause of the method!!!


-----

- current device discovery (rewriting threading)

	> backgorund thread NETWORK discovery
		Network disc module
		   Return ALL Current (even if disconencted)
		   Do logic so 'refrsh tick' wakeup called on Webservice calls?
		   Then time based scanning for new networks.
		   Say up to 60 minutes if no wakeups.
		   But otherwise typically around once ever 30 seconds (if actively getting WS calls).
	

	  > SIMILAR background thread doing Device discovery 
	     > checks all current networks
		 > similar slowdown if inactive
		 > periodcally call arp -a to get a list of candidates
		 > peridocally check candidates randomly from active networks
		 > PING them for now - but eventually also try other ways like connecting to port 22, etc.
		 > Store MUCH more data on discovered devices
		 > Load/save this to/from Database
		 > have ALL CURRENT (for network) and maybe (ALL EVER) for network APIs to do fetches

	DONT

	-- See https://www.w3.org/2009/dap/track/issues/151
	  DONT USE USN (docuemnt in stroika what it is and used for)
		For device, use UDN 
		"true device identifier that is the same for all services and embedded devices (and their respective services) under the same root UPnP device can be found in the <UDN> element of the root device description document."


	> Add suport for ARP -a for discovery

	>	NEXT - SEE IF SOMETHING SIMPLE TODO TO GET BETTER GUESSES AT DEVICE deviceType
		(maybe replace TYPE with ICON, and have a list of icons
		and with persistence UI can associate icons with devices?
		)

	>	At least someting so sonos speakers show up special? Maybe have CLASES (can be in more than one claass
		and if you support a given INTERFACE you get that class)

		Classes = "Windows device" | "Unix Device"  (and windows might be in both with WSL)
		if it shows - windows means has 'netbios and ???'
		'MacOS device'?

			Windows Media Server

			speakers

			Router (or better - Network Infrastrucutre for routers, WAPs etc)
			Maybe ROUTER AND NetworkInfrastrucutre

			(then GUI can devide how to 'show' if in multiple classes)



-----
CLEANUP OUTPUT

  Compiling Backend/Sources/Service.cpp ...
         Compiling Backend/Sources/WebServices/WebServer.cpp ...
         Linking  $StroikaRoot/Builds/Release/WhyTheFuckIsMyNetworkSoSlow/WhyTheFuckIsMyNetworkSoSlow-Backend...

(new stroikaroot .... stuff)


----

	DEFAULT PORT = config file and command-line args override and config-file-location override???
		/var/opt/WhyTheFuckIsMyNetworkSoSlow/Configuration/xxx
			StaticContentWebServerAddress : default is 0.0.0.0
			StaticContentWebServerPort
			WebServiceAddress : default is 0.0.0.0
			WebServicePort

		.../Configuration-Defaults
			Print out the default values for each configurable value, which can be used to update config file

------

http://localhost:8080/Network/97979b96-9967-6696-95cb-6495706c66c9
	ONLY prints ONE Network_Address - should print BOTH the IPv4 and IPv6 networks there.
	its attached interafce http://localhost:8080/NetworkInterface/56f0fbd0-a2ec-4e00-9c05-61e449fdbfc4
		shows several ipv6 addresses, with probably:
			fe80::b80f:7c29:847f:2322/64 being the one I should label as the network? Maybe not. Maybe its fe80:: that is the network cuz the rest SB 0's... (lower 64 bits)
			OR could be ff02::???

-----

	//// MAYBE then add APIs
	// to measure TIME BETWEEN NODES and TIME TO ADDRESS
	// AND MAYBE HAVE "MONTIORS - where we defifine set of links to montir and then can check back on historical
	values for those?"


====

		>	Document new clearer design - Networks, NetworkIntraces, Devices

		>	Document TIME aspect (param to queries saying "now" or "some temporal notion") - applies to top level queries and
			queries in a network (filtered), or even queries by ID (e.g. /Device/xxxx?time=recent-average?)


		>	Document prelim ideas on measurements, like device-2-device times (disatnce) and how they get stored

----

Under docker:

00007fdd7e147700][0002.603]                  No speed for interface lo, errno=95
[0x00007fdd7e147700][0002.603]                  ethtool_cmd_speed (&edata)=10000
[0x00007fdd7e147700][0002.607]                  <IO::Network::Socket::Bind (sockAddr=INADDR_ANY:1900 bindFlags.fReUseAddr=true)/>
[0x00007fdd7e147700][0002.607]                  <IO::Network::Socket::JoinMulticastGroup (iaddr=239.255.255.250 onInterface=INADDR_ANY)/>
[0x00007fdd7e147700][0002.608]                  <IO::Network::Socket::Bind (sockAddr=in6addr_any:1900 bindFlags.fReUseAddr=true)/>
[0x00007fdd7e147700][0002.609]                  <IO::Network::Socket::JoinMulticastGroup (iaddr=ff02::c onInterface=INADDR_ANY)> {
[0x00007fdd7e147700][0002.655]                          errno_ErrorException::Throw (19) - throwing errno_ErrorException 'No such device (errno: 19)' from /usr/lib/x86_64-linux-gnu/libasan.so.4(+0x558c0) [0x7fdd84ca88c0]; ./Builds/Debug/WhyTheFuckIsMyNetworkSoSlow/WhyTheFuckIsMyNetworkSoSlow-Backend(Stroika::Foundation::Debug::BackTrace[abi:cxx11](unsigned int)+0x22b) [0x55bb03f5f5b5]; ./Builds/Debug/WhyTheFuckIsMyNetworkSoSlow/WhyTheFuckIsMyNetworkSoSlow-Backend(Stroika::Foundation::Execution::Private_::GetBT_ws[abi:cxx11]()+0xba) [0x55bb03f73834]; ./Builds/Debug/WhyTh



>>> HANDLE BETTER when multicast crap doesn't work. Seems common enough - just log it as an erorr and set some error state, but keep running
!!!!


------------------------------------------


>>> NEXT SIMPLE FUNCTION
	>	ComputeAverageTimeToInternet()
		Run a tracert, and stop at the first public IP address. (or navigate to www.sophists.com, and www.google.com, and grab meet of two paths)

		Maybe option for two notions of internet

		>	Take that function - and somehow expopse it as REST WS API
			grab current value, and keep running in background - every 5 minutes, and report statistics

		>	This is a very primitive first draft/try - but the starting point for collecting stats


 ----
 
 >>> In discovery - look at location, and then fetch that location (at least sometimes) in xml
		http://192.168.244.1:47956/rootDesc.xml

		and that maybe info about the device - in that case it was - with <friendlyname> which we can diospaly and <deviceType>
urn:schemas-upnp-org:device:InternetGatewayDevice:1
</deviceType>


> Need to make a UUID property for devices for fronted to use to identify selected or not


>>>> Check for IF HAS PERMISSIONS TO OPEN PORT 80 and GIVE BETTER ERROR MESSAGE