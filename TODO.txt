Top priority bug:

>	Script building release
  and fix installer names so include -Debug/-Release (or maybe not for release)
	and include version# on windows msi Builds


> Fix parsing of SSDP presentationURL, and see that it shows up properly in the web GUI for devices (all the
  rest should be plumbed - just the stroika ssdp parse code is questionable/incomplete)



- On unix - see why 'wifi0' is displayed as "Wired Ethernet" type? SB wireless!

- extra layer of caching on reverse dns name lookup - so doesn't waste time / block
  (could use async dns?)

- Add new stroika module 'IO::Network::Neighbors'
  - https://www.midnightfreddie.com/how-to-arp-a-in-ipv6.html
	- http://man7.org/linux/man-pages/man8/ip-neighbour.8.html
	- arp -a
	- ip neigh show
	- ip -6 neigh show
	- cat  /proc/net/arp
	- use that to fill in new devices / info for discovery


- Add HardwareAddress to list of things captured in devices info (currenly done in discovert-deviceinfo but expose)


## THINGS TO ASK BOB TODO:
- ask bob how to turn on/off debug mode - nice if user settable option (dialog) 
  or at worst ?debugmode=true on url; in general - how do we handle configuraiton
- suggest to bob fix scroller so doesn't scroll heading - just the bottom alreayd
- some sort of grouping of devices
- auto-refresh list of devices in the background (really cool if could animate additions/removeals/changes)
- in about box just aggregate release notes in build - and link to from about box
- THEN - with those basics out of the way - time to talk about next-gen GUI
- filter by 'search string'
- filter by 'network'
- filter by 'present now'



- maybe setup WTF website (or section of sophists site)


- ADD "OS" to properties assocaited with a device 
  Typically "Windows" or "Linux" (?useful?). Make it structure, with extra info
	Windows {build : n, edition : x}
	Linux { "distribution ubuntu 1404"}
	Unix { some otehr posix based unix}
	MacOS { version }

	*** DEFINE GENERIC OS-INFO object. Use in each device and in AboutInfo object - for what we are running on.
	    See how 'about' object fits with the /data-providers idea? Maybe there is where to declare at least
			this data provider?


>> ADD TO WS DATA MODEL - 'THIS DEVICE' 
flag so you can tell which device is the one querying
  (flag saying "WTFDataProvider: URL) - our 8000 url)
	(and field saying data-collected-by, but not sure where since belongs as higher level elt)
	(and returning an array here); COULD aggregatate array or could have separate API or use HTTP-header
	(ah -if we say 'data provider url and its teh same were fetching from we know same source. maybe have data provider url and GUID)
	{wtf-data-provider: {guid: xxx; url: xxx}}

maybe GET /data-providers

and data-provider guid (or set) arg allowed in fetch of devices



>>> Why sonos devices in family room (play5s) not showing up their roomname (works about 1/2 the time - works for other speakers)



>>> Add "Device ICON UrL" support and push all the way to GUI, so Bob can fetch that image and display



> Need ChangeCount mechanism - where you wait to get notified on changes 

  - use condition variable
	- when a change happens in network data (or device data) - we up a change ChangeCount and notify
	- define associated callbacks that get called on change
	- have thread driving callbacks
	- thread smart enuf to to re-call callbacks if change happens AGAIN while handling reaction


struct ChangeMonitor {
	ChangeMonitor ();	// starts monitoring
	~ChangeMonitor (); aborts and waits for callbacks if needed

	void AddCallback (Function<> cb);
	void RemoveCallback (Function<> cb);
	void NoteChanged ();

	uint64_t GetChangeCount () const;

private:
	Thread::CleanupPtr fChangeMonitorThread;
	Set<Function<>> fCallbacks;
	ConditionVariable<> fWaitOn;
	atomicuint64_t fChangeCount;
}


- Add "RunningOn" info to 'about' data structure (WSAPI) and About GUI


- Use Cache object on URL looks (GET) for SSDP data. That's probably one of the more expensive items to
  lookup, and esp if we cache the (negative cache) resulkt of failed fetch (bad url) - we can save item.
	Just write utility function to lookup (URL u) -> SSDP::DEscription  - and have it maintain the cache object.
	For a given url, probably no value in lookup more than once per hour or day? Or better - maybe use GetIFMODIFIED and save
	ETAGS in that cache structure (may need new stroika cache for this).

  - MAYBE add obj wrapper on client connection object which maintains cache? and uses ETAGS?



>>> When we recive SSDP events we get many for a given device (rooot and subdevies).
Add tracking info about time we've seen alive (and maybe if we ping it - time we know dead) ; so times KNOWN alive and times KNOWN
dead? Unsure how to handle hte in-betweens. Need some good guessing strategy or only report known info?


Need notificyuatopm/event when netowrk changes
	WHEN - must re-run over list of devices andu
	update thier list of networks.

	And maybe more

-- and separate issue as performance tweek see if I can register in stroikaroota
on network change event so I can avoid polling but poling OK to start.



GetMyDEvice needs its own thread (waiting on notification thatnetwork changed). Condition variable notify all.



	(then add a thread that periodically calls arp -a)
	(then eventually add another thread that walks all available active networks and randoming pings in that range to discover)







---
[0x00005bb4][0115.326]		<Router::Rep_::HandleMessage ((...method=GET,url=http:favicon.ico))> {
[0x00005bb4][0115.335]			Throwing exception: HTTP exception: status 405 (Method Not allowed) from 
Exception thrown at 0x00007FF959CD5549 in WhyTheFuckIsMyNetworkSoSlow-Backend.exe: Microsoft C++ exception: Stroika::Foundation::IO::Network::HTTP::ClientErrorException at memory location 0x000000000326C9E0.


WSAPI above - if we fetch soemting that we dont have issue 404 and only 405 if it was ebcause of the method!!!


-----

- current device discovery (rewriting threading)

	> backgorund thread NETWORK discovery
		Network disc module
		   Return ALL Current (even if disconencted)
		   Do logic so 'refrsh tick' wakeup called on Webservice calls?
		   Then time based scanning for new networks.
		   Say up to 60 minutes if no wakeups.
		   But otherwise typically around once ever 30 seconds (if actively getting WS calls).
	

	  > SIMILAR background thread doing Device discovery 
	     > checks all current networks
		 > similar slowdown if inactive
		 > periodcally call arp -a to get a list of candidates
		 > peridocally check candidates randomly from active networks
		 > PING them for now - but eventually also try other ways like connecting to port 22, etc.
		 > Store MUCH more data on discovered devices
		 > Load/save this to/from Database
		 > have ALL CURRENT (for network) and maybe (ALL EVER) for network APIs to do fetches

	DONT

	-- See https://www.w3.org/2009/dap/track/issues/151
	  DONT USE USN (docuemnt in stroika what it is and used for)
		For device, use UDN 
		"true device identifier that is the same for all services and embedded devices (and their respective services) under the same root UPnP device can be found in the <UDN> element of the root device description document."


	> Add suport for ARP -a for discovery

	>	NEXT - SEE IF SOMETHING SIMPLE TODO TO GET BETTER GUESSES AT DEVICE deviceType
		(maybe replace TYPE with ICON, and have a list of icons
		and with persistence UI can associate icons with devices?
		)

	>	At least someting so sonos speakers show up special? Maybe have CLASES (can be in more than one claass
		and if you support a given INTERFACE you get that class)

		Classes = "Windows device" | "Unix Device"  (and windows might be in both with WSL)
		if it shows - windows means has 'netbios and ???'
		'MacOS device'?

			Windows Media Server

			speakers

			Router (or better - Network Infrastrucutre for routers, WAPs etc)
			Maybe ROUTER AND NetworkInfrastrucutre

			(then GUI can devide how to 'show' if in multiple classes)



-----
CLEANUP OUTPUT

  Compiling Backend/Sources/Service.cpp ...
         Compiling Backend/Sources/WebServices/WebServer.cpp ...
         Linking  $StroikaRoot/Builds/Release/WhyTheFuckIsMyNetworkSoSlow/WhyTheFuckIsMyNetworkSoSlow-Backend...

(new stroikaroot .... stuff)


----

	DEFAULT PORT = config file and command-line args override and config-file-location override???
		/var/opt/WhyTheFuckIsMyNetworkSoSlow/Configuration/xxx
			StaticContentWebServerAddress : default is 0.0.0.0
			StaticContentWebServerPort
			WebServiceAddress : default is 0.0.0.0
			WebServicePort

		.../Configuration-Defaults
			Print out the default values for each configurable value, which can be used to update config file

------

http://localhost:8080/Network/97979b96-9967-6696-95cb-6495706c66c9
	ONLY prints ONE Network_Address - should print BOTH the IPv4 and IPv6 networks there.
	its attached interafce http://localhost:8080/NetworkInterface/56f0fbd0-a2ec-4e00-9c05-61e449fdbfc4
		shows several ipv6 addresses, with probably:
			fe80::b80f:7c29:847f:2322/64 being the one I should label as the network? Maybe not. Maybe its fe80:: that is the network cuz the rest SB 0's... (lower 64 bits)
			OR could be ff02::???

-----

	//// MAYBE then add APIs
	// to measure TIME BETWEEN NODES and TIME TO ADDRESS
	// AND MAYBE HAVE "MONTIORS - where we defifine set of links to montir and then can check back on historical
	values for those?"


====

		>	Document new clearer design - Networks, NetworkIntraces, Devices

		>	Document TIME aspect (param to queries saying "now" or "some temporal notion") - applies to top level queries and
			queries in a network (filtered), or even queries by ID (e.g. /Device/xxxx?time=recent-average?)


		>	Document prelim ideas on measurements, like device-2-device times (disatnce) and how they get stored

----

Under docker:

00007fdd7e147700][0002.603]                  No speed for interface lo, errno=95
[0x00007fdd7e147700][0002.603]                  ethtool_cmd_speed (&edata)=10000
[0x00007fdd7e147700][0002.607]                  <IO::Network::Socket::Bind (sockAddr=INADDR_ANY:1900 bindFlags.fReUseAddr=true)/>
[0x00007fdd7e147700][0002.607]                  <IO::Network::Socket::JoinMulticastGroup (iaddr=239.255.255.250 onInterface=INADDR_ANY)/>
[0x00007fdd7e147700][0002.608]                  <IO::Network::Socket::Bind (sockAddr=in6addr_any:1900 bindFlags.fReUseAddr=true)/>
[0x00007fdd7e147700][0002.609]                  <IO::Network::Socket::JoinMulticastGroup (iaddr=ff02::c onInterface=INADDR_ANY)> {
[0x00007fdd7e147700][0002.655]                          errno_ErrorException::Throw (19) - throwing errno_ErrorException 'No such device (errno: 19)' from /usr/lib/x86_64-linux-gnu/libasan.so.4(+0x558c0) [0x7fdd84ca88c0]; ./Builds/Debug/WhyTheFuckIsMyNetworkSoSlow/WhyTheFuckIsMyNetworkSoSlow-Backend(Stroika::Foundation::Debug::BackTrace[abi:cxx11](unsigned int)+0x22b) [0x55bb03f5f5b5]; ./Builds/Debug/WhyTheFuckIsMyNetworkSoSlow/WhyTheFuckIsMyNetworkSoSlow-Backend(Stroika::Foundation::Execution::Private_::GetBT_ws[abi:cxx11]()+0xba) [0x55bb03f73834]; ./Builds/Debug/WhyTh



>>> HANDLE BETTER when multicast crap doesn't work. Seems common enough - just log it as an erorr and set some error state, but keep running
!!!!


------------------------------------------


>>> NEXT SIMPLE FUNCTION
	>	ComputeAverageTimeToInternet()
		Run a tracert, and stop at the first public IP address. (or navigate to www.sophists.com, and www.google.com, and grab meet of two paths)

		Maybe option for two notions of internet

		>	Take that function - and somehow expopse it as REST WS API
			grab current value, and keep running in background - every 5 minutes, and report statistics

		>	This is a very primitive first draft/try - but the starting point for collecting stats


 ----
 
 >>> In discovery - look at location, and then fetch that location (at least sometimes) in xml
		http://192.168.244.1:47956/rootDesc.xml

		and that maybe info about the device - in that case it was - with <friendlyname> which we can diospaly and <deviceType>
urn:schemas-upnp-org:device:InternetGatewayDevice:1
</deviceType>


> Need to make a UUID property for devices for fronted to use to identify selected or not


>>>> Check for IF HAS PERMISSIONS TO OPEN PORT 80 and GIVE BETTER ERROR MESSAGE